name: Deploy RentalTurnManager

on:
  push:
    branches:
      - main
      - dev
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  DOTNET_VERSION: '10.0.x'
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  OIDC_ROLE_NAME: ${{ vars.OIDC_ROLE_NAME }}

jobs:
  test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore src/RentalTurnManager.sln

      - name: Build
        run: dotnet build src/RentalTurnManager.sln --configuration Release --no-restore

      - name: Run tests
        run: dotnet test src/RentalTurnManager.sln --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --results-directory ./coverage

      - name: Code Coverage Report
        uses: codecov/codecov-action@v3
        with:
          directory: ./coverage
          fail_ci_if_error: false

      - name: Check code coverage threshold
        run: |
          # This is a placeholder - implement actual coverage check
          echo "Code coverage check passed"

  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Set environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Display environment
        run: echo "Deploying to ${{ steps.set-env.outputs.environment }}"

  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [test, determine-environment]
    environment: ${{ needs.determine-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      APP_NAME: ${{ vars.APP_NAME || 'RentalTurnManager' }}
      NAMESPACE_PREFIX: ${{ vars.NAMESPACE_PREFIX || 'bf' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.OIDC_ROLE_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Lambda tools
        run: dotnet tool install -g Amazon.Lambda.Tools

      - name: Prepare properties configuration
        if: vars.PROPERTIES_CONFIG != ''
        run: |
          cat > config/properties.json << 'EOF'
          ${{ vars.PROPERTIES_CONFIG }}
          EOF

      - name: Build Lambda package
        run: |
          cd src/RentalTurnManager.Lambda
          dotnet lambda package --configuration Release --framework net10.0 --output-package ../../lambda-deployment.zip

      - name: Build Callback Lambda package
        run: |
          cd src/RentalTurnManager.CallbackLambda
          dotnet lambda package --configuration Release --framework net10.0 --output-package ../../callback-lambda-deployment.zip

      - name: Create/Update S3 deployment bucket
        run: |
          BUCKET_NAME="${{ vars.NAMESPACE_PREFIX || 'bf' }}-${{ env.ENVIRONMENT }}-s3-deployments"
          aws s3 mb s3://${BUCKET_NAME} --region ${{ env.AWS_REGION }} 2>/dev/null || true
          echo "BUCKET_NAME=${BUCKET_NAME}" >> $GITHUB_ENV

      - name: Upload Lambda package to S3
        run: |
          aws s3 cp lambda-deployment.zip s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/lambda/lambda-deployment.zip
          aws s3 cp callback-lambda-deployment.zip s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/lambda/callback-lambda-deployment.zip

      - name: Upload Step Functions definition to S3
        run: |
          aws s3 cp infrastructure/stepfunctions/cleaner-workflow.json s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/stepfunctions/${{ env.ENVIRONMENT }}/cleaner-workflow.json

      - name: Upload configuration files to S3
        run: |
          aws s3 cp config/properties.json s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/config/${{ env.ENVIRONMENT }}/properties.json
          aws s3 cp config/message-templates.json s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/config/${{ env.ENVIRONMENT }}/message-templates.json

      - name: Deploy CloudFormation stack
        run: |
          STACK_NAME="${{ env.NAMESPACE_PREFIX }}-${{ env.ENVIRONMENT }}-stack-${{ env.APP_NAME }}"
          
          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name ${STACK_NAME} --region ${{ env.AWS_REGION }} 2>/dev/null; then
            ACTION="update-stack"
            WAIT_CONDITION="stack-update-complete"
          else
            ACTION="create-stack"
            WAIT_CONDITION="stack-create-complete"
          fi
          
          # Prepare JSON parameters (minify to single line and create override parameters file)
          cat > /tmp/properties.json << 'PROPERTIES_EOF'
          ${{ vars.PROPERTIES_CONFIG || '{}' }}
          PROPERTIES_EOF
          cat > /tmp/templates.json << 'TEMPLATES_EOF'
          ${{ vars.MESSAGE_TEMPLATES || '{}' }}
          TEMPLATES_EOF
          PROPERTIES_CONFIG=$(jq -c . /tmp/properties.json)
          MESSAGE_TEMPLATES=$(jq -c . /tmp/templates.json)
          
          # Create override parameters file using jq to properly escape JSON strings
          jq -n \
            --arg email_user "${{ secrets.EMAIL_USERNAME }}" \
            --arg email_pass "${{ secrets.EMAIL_PASSWORD }}" \
            --arg owner_email "${{ vars.OWNER_EMAIL }}" \
            --arg imap_host "${{ vars.IMAP_HOST }}" \
            --arg imap_port "${{ vars.IMAP_PORT || '993' }}" \
            --arg schedule "${{ vars.SCHEDULE_INTERVAL || 'rate(15 minutes)' }}" \
            --arg owner_name "${{ vars.OWNER_NAME || 'Property Owner' }}" \
            --arg namespace "${{ env.NAMESPACE_PREFIX }}" \
            --arg app_name "${{ env.APP_NAME }}" \
            --arg props_config "${PROPERTIES_CONFIG}" \
            --arg msg_templates "${MESSAGE_TEMPLATES}" \
            '[
              {ParameterKey: "EmailUsername", ParameterValue: $email_user},
              {ParameterKey: "EmailPassword", ParameterValue: $email_pass},
              {ParameterKey: "OwnerEmail", ParameterValue: $owner_email},
              {ParameterKey: "ImapHost", ParameterValue: $imap_host},
              {ParameterKey: "ImapPort", ParameterValue: $imap_port},
              {ParameterKey: "ScheduleInterval", ParameterValue: $schedule},
              {ParameterKey: "OwnerName", ParameterValue: $owner_name},
              {ParameterKey: "NamespacePrefix", ParameterValue: $namespace},
              {ParameterKey: "AppName", ParameterValue: $app_name},
              {ParameterKey: "PropertiesConfig", ParameterValue: $props_config},
              {ParameterKey: "MessageTemplates", ParameterValue: $msg_templates}
            ]' > /tmp/override-params.json
          
          # Deploy stack
          aws cloudformation ${ACTION} \
            --stack-name ${STACK_NAME} \
            --template-body file://infrastructure/cloudformation/main.yaml \
            --parameters file://infrastructure/cloudformation/parameters/${{ env.ENVIRONMENT }}.json \
            --parameters file:///tmp/override-params.json \
            --capabilities CAPABILITY_NAMED_IAM \
            --region ${{ env.AWS_REGION }} \
            --tags \
              Key=OwnerName,Value="${{ vars.OWNER_NAME || 'Owner Name' }}" \
              Key=Environment,Value="${{ env.ENVIRONMENT }}" \
              Key=AppName,Value="${{ env.APP_NAME }}" \
              Key=Description,Value="${{ vars.APP_DESCRIPTION || 'Rental property turnover management system' }}" \
              Key=GitHubRepo,Value="${{ github.repository }}" \
              Key=GitHubSHA,Value="${{ github.sha }}"
          
          # Wait for stack operation to complete
          aws cloudformation wait ${WAIT_CONDITION} \
            --stack-name ${STACK_NAME} \
            --region ${{ env.AWS_REGION }}

      - name: Update Lambda function code
        run: |
          FUNCTION_NAME="${{ env.NAMESPACE_PREFIX }}-${{ env.ENVIRONMENT }}-lambda-${{ env.APP_NAME }}"
          
          aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --s3-bucket ${{ env.BUCKET_NAME }} \
            --s3-key ${{ env.APP_NAME }}/lambda/lambda-deployment.zip \
            --region ${{ env.AWS_REGION }}
          
          # Wait for update to complete
          aws lambda wait function-updated \
            --function-name ${FUNCTION_NAME} \
            --region ${{ env.AWS_REGION }}

      - name: Get stack outputs
        id: stack-outputs
        run: |
          STACK_NAME="${{ env.NAMESPACE_PREFIX }}-${{ env.ENVIRONMENT }}-stack-${{ env.APP_NAME }}"
          
          LAMBDA_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaFunctionArn`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          STATE_MACHINE_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`StateMachineArn`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "lambda-arn=${LAMBDA_ARN}" >> $GITHUB_OUTPUT
          echo "state-machine-arn=${STATE_MACHINE_ARN}" >> $GITHUB_OUTPUT

      - name: Deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Lambda Function:** ${{ steps.stack-outputs.outputs.lambda-arn }}" >> $GITHUB_STEP_SUMMARY
          echo "**State Machine:** ${{ steps.stack-outputs.outputs.state-machine-arn }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
