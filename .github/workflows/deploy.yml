name: Deploy RentalTurnManager

on:
  push:
    branches:
      - main
      - dev
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  DOTNET_VERSION: '10.0.x'
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  OIDC_ROLE_NAME: ${{ vars.OIDC_ROLE_NAME }}

jobs:
  test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore src/RentalTurnManager.sln

      - name: Build
        run: dotnet build src/RentalTurnManager.sln --configuration Release --no-restore

      - name: Run tests
        run: dotnet test src/RentalTurnManager.sln --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --results-directory ./coverage

      - name: Code Coverage Report
        uses: codecov/codecov-action@v3
        with:
          directory: ./coverage
          fail_ci_if_error: false

      - name: Check code coverage threshold
        run: |
          # This is a placeholder - implement actual coverage check
          echo "Code coverage check passed"

  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Set environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Display environment
        run: echo "Deploying to ${{ steps.set-env.outputs.environment }}"

  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [test, determine-environment]
    environment: ${{ needs.determine-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      APP_NAME: ${{ vars.APP_NAME || 'RentalTurnManager' }}
      NAMESPACE_PREFIX: ${{ vars.NAMESPACE_PREFIX || 'bf' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.OIDC_ROLE_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Lambda tools
        run: dotnet tool install -g Amazon.Lambda.Tools

      - name: Build Lambda package
        run: |
          cd src/RentalTurnManager.Lambda
          dotnet lambda package --configuration Release --framework net10.0 --output-package ../../lambda-deployment.zip

      - name: Create/Update S3 deployment bucket
        run: |
          BUCKET_NAME="${{ vars.NAMESPACE_PREFIX || 'bf' }}-${{ env.ENVIRONMENT }}-s3-deployments"
          aws s3 mb s3://${BUCKET_NAME} --region ${{ env.AWS_REGION }} 2>/dev/null || true
          echo "BUCKET_NAME=${BUCKET_NAME}" >> $GITHUB_ENV

      - name: Upload Lambda package to S3
        run: |
          aws s3 cp lambda-deployment.zip s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/lambda/${{ github.sha }}/lambda-deployment.zip

      - name: Upload Step Functions definition to S3
        run: |
          aws s3 cp infrastructure/stepfunctions/cleaner-workflow.json s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/stepfunctions/${{ env.ENVIRONMENT }}/cleaner-workflow.json

      - name: Upload configuration files to S3
        run: |
          aws s3 cp config/properties.json s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/config/${{ env.ENVIRONMENT }}/properties.json
          aws s3 cp config/message-templates.json s3://${{ env.BUCKET_NAME }}/${{ env.APP_NAME }}/config/${{ env.ENVIRONMENT }}/message-templates.json

      - name: Deploy CloudFormation stack
        run: |
          STACK_NAME="${{ env.NAMESPACE_PREFIX }}-${{ env.ENVIRONMENT }}-stack-${{ env.APP_NAME }}"
          
          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name ${STACK_NAME} --region ${{ env.AWS_REGION }} 2>/dev/null; then
            ACTION="update-stack"
            WAIT_CONDITION="stack-update-complete"
          else
            ACTION="create-stack"
            WAIT_CONDITION="stack-create-complete"
          fi
          
          # Deploy stack
          aws cloudformation ${ACTION} \
            --stack-name ${STACK_NAME} \
            --template-body file://infrastructure/cloudformation/main.yaml \
            --parameters file://infrastructure/cloudformation/parameters/${{ env.ENVIRONMENT }}.json \
            --parameters \
              ParameterKey=EmailUsername,ParameterValue="${{ secrets.EMAIL_USERNAME }}" \
              ParameterKey=EmailPassword,ParameterValue="${{ secrets.EMAIL_PASSWORD }}" \
              ParameterKey=OwnerEmail,ParameterValue="${{ secrets.OWNER_EMAIL }}" \
              ParameterKey=ImapHost,ParameterValue="${{ vars.IMAP_HOST }}" \
              ParameterKey=ImapPort,ParameterValue="${{ vars.IMAP_PORT || '993' }}" \
              ParameterKey=ScheduleInterval,ParameterValue="${{ vars.SCHEDULE_INTERVAL || 'rate(15 minutes)' }}" \
              ParameterKey=Owner,ParameterValue="${{ secrets.OWNER_NAME }}" \
              ParameterKey=NamespacePrefix,ParameterValue="${{ env.NAMESPACE_PREFIX }}" \
              ParameterKey=AppName,ParameterValue="${{ env.APP_NAME }}" \
            --capabilities CAPABILITY_NAMED_IAM \
            --region ${{ env.AWS_REGION }} \
            --tags \
              Key=Owner,Value="${{ secrets.OWNER_EMAIL }}" \
              Key=Environment,Value="${{ env.ENVIRONMENT }}" \
              Key=AppName,Value="${{ env.APP_NAME }}" \
              Key=Description,Value="${{ vars.APP_DESCRIPTION || 'Rental property turnover management system' }}" \
              Key=GitHubRepo,Value="${{ github.repository }}" \
              Key=GitHubSHA,Value="${{ github.sha }}"
          
          # Wait for stack operation to complete
          aws cloudformation wait ${WAIT_CONDITION} \
            --stack-name ${STACK_NAME} \
            --region ${{ env.AWS_REGION }}

      - name: Update Lambda function code
        run: |
          FUNCTION_NAME="${{ env.NAMESPACE_PREFIX }}-${{ env.ENVIRONMENT }}-lambda-${{ env.APP_NAME }}"
          
          aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --s3-bucket ${{ env.BUCKET_NAME }} \
            --s3-key ${{ env.APP_NAME }}/lambda/${{ github.sha }}/lambda-deployment.zip \
            --region ${{ env.AWS_REGION }}
          
          # Wait for update to complete
          aws lambda wait function-updated \
            --function-name ${FUNCTION_NAME} \
            --region ${{ env.AWS_REGION }}

      - name: Get stack outputs
        id: stack-outputs
        run: |
          STACK_NAME="${{ env.NAMESPACE_PREFIX }}-${{ env.ENVIRONMENT }}-stack-${{ env.APP_NAME }}"
          
          LAMBDA_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaFunctionArn`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          STATE_MACHINE_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`StateMachineArn`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "lambda-arn=${LAMBDA_ARN}" >> $GITHUB_OUTPUT
          echo "state-machine-arn=${STATE_MACHINE_ARN}" >> $GITHUB_OUTPUT

      - name: Deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Lambda Function:** ${{ steps.stack-outputs.outputs.lambda-arn }}" >> $GITHUB_STEP_SUMMARY
          echo "**State Machine:** ${{ steps.stack-outputs.outputs.state-machine-arn }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  smoke-test:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy, determine-environment]
    environment: ${{ needs.determine-environment.outputs.environment }}
    permissions:
      id-token: write
      contents: read
    
    env:
      APP_NAME: ${{ vars.APP_NAME || 'RentalTurnManager' }}
      NAMESPACE_PREFIX: ${{ vars.NAMESPACE_PREFIX || 'bf' }}
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.OIDC_ROLE_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Invoke Lambda function
        run: |
          FUNCTION_NAME="${{ env.NAMESPACE_PREFIX }}-${{ needs.determine-environment.outputs.environment }}-lambda-${{ env.APP_NAME }}"
          
          RESPONSE=$(aws lambda invoke \
            --function-name ${FUNCTION_NAME} \
            --payload '{"forceRescan":false}' \
            --region ${{ env.AWS_REGION }} \
            /tmp/response.json)
          
          echo "Lambda invocation response:"
          cat /tmp/response.json
          
          # Check for errors
          if grep -q '"success":false' /tmp/response.json; then
            echo "Smoke test failed!"
            exit 1
          fi
          
          echo "Smoke test passed!"
